########################################
# Initialize
########################################

if ( test $(readlink "${HOME}/.zshrc") -nt "${HOME}/.zshrc.zwc" ); then
  zcompile "${HOME}/.zshrc"
fi

source "${HOME}/.zshenv"

if ( test -f "${HOME}/.zshrc.alias" ); then
  source "${HOME}/.zshrc.alias"
fi

if ( test -f "${HOME}/.zshrc.local" ); then
  source "${HOME}/.zshrc.local"
fi

# anyenv
eval "$(anyenv init - --no-rehash)"

# direnv
eval "$(direnv hook zsh)"

########################################
# Color
########################################

export TERM="xterm-256color"

autoload -Uz colors
colors

local DEFAULT=$'%{\e[0;0m%}'
local RESET="%{${reset_color}%}"
local WHITE="%{${fg[white]}%}"
local GREEN="%{${fg[green]}%}"
local BOLD_GREEN="%{${fg_bold[green]}%}"
local BLUE="%{${fg[blue]}%}"
local BOLD_BLUE="%{${fg_bold[blue]}%}"
local RED="%{${fg[red]}%}"
local BOLD_RED="%{${fg_bold[red]}%}"
local CYAN="%{${fg[cyan]}%}"
local BOLD_CYAN="%{${fg_bold[cyan]}%}"
local YELLOW="%{${fg[yellow]}%}"
local BOLD_YELLOW="%{${fg_bold[yellow]}%}"
local MAGENTA="%{${fg[magenta]}%}"
local BOLD_MAGENTA="%{${fg_bold[magenta]}%}"

########################################
# Options
########################################

# ref: http://karur4n.hatenablog.com/entry/2016/01/18/100000
setopt no_global_rcs

setopt nobeep
setopt nolistbeep
setopt ignoreeof

bindkey -v

# history
bindkey '^k' up-line-or-history
bindkey '^j' down-line-or-history

setopt extended_history
setopt hist_expand
setopt hist_ignore_all_dups
setopt hist_no_store
setopt share_history
setopt hist_reduce_blanks

########################################
# Completion
########################################

autoload -Uz compinit && compinit

setopt auto_list
setopt auto_menu
setopt auto_param_slash
setopt auto_pushd
setopt correct
setopt list_packed
setopt list_types
setopt magic_equal_subst
setopt pushd_ignore_dups

zstyle ':completion:*:default' menu select
zstyle ':completion:*' list-separator '=>'
zstyle ':completion:*:manuals' separate-sections true
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*' list-colors 'di=34' 'ln=35' 'so=32' 'ex=31' 'bd=46;34' 'cd=43;34'

zstyle ':completion:*' verbose yes
zstyle ':completion:*' completer _expand _complete _match _prefix _list _approximate
zstyle ':completion:*:messages' format '%F{yellow}%d'${DEFAULT}
zstyle ':completion:*:warnings' format '%F{red}No matches for:''%F{yellow} %d'${DEFAULT}
zstyle ':completion:*:corrections' format '%F{yellow}%d ''%F{red}(errors: %e)%b'${DEFAULT}
zstyle ':completion:*:descriptions' format '%F{yellow}completing %B%d%b'${DEFAULT}
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*' group-name ''

########################################
# Prompt
########################################

setopt prompt_subst

autoload -Uz add-zsh-hook
autoload -Uz vcs_info
autoload -Uz is-at-least

PROMPT="${BLUE}[%1v]${RESET} ${GREEN}%~${RESET}
$ "
PROMPT2='> '
SPROMPT='"%r" is correct? ([Y]es, [n]o, [a]bort, [e]dit):'

precmd() {
  LANG='en_US.UTF-8'
  psvar=()

  psvar[1]='papix'
  vcs_info
  [[ -n "${vcs_info_msg_0_}" ]] && psvar[2]="${vcs_info_msg_0_}"
}

RPROMPT="%2(v|${GREEN}%2v${RESET}|)"

# ref: http://mollifier.hatenablog.com/entry/20100906/p1
zstyle ':vcs_info:*' enable git svn hg bzr

zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:git:*' formats '[%b%c%u]'
zstyle ':vcs_info:git:*' actionformats '[%b|%a%c%u]'
zstyle ':vcs_info:git:*' stagedstr '+'
zstyle ':vcs_info:git:*' unstagedstr '-'

zstyle ':vcs_info:(svn|hg|bzr)' formats '(%s)[%b]'
zstyle ':vcs_info:(svn|hg|bzr)' actionformats '(%s)[%b|%a]'
zstyle ':vcs_info:(svn|bzr):*' branchformat '%b:r%r'
zstyle ':vcs_info:bzr:*' use-simple true

########################################
# tmux
########################################

if ( which tmux > /dev/null ) && ( ! test $TMUX ) && tmux has-session; then
  echo "Attache tmux session"
  tmux attach && exit
  else
  echo "Create new tmux session."
  if ( test -f "${HOME}/.init.sh" ); then
    "${HOME}/.init.sh"
  fi
  tmux -u -2 && exit
fi

########################################
# cd
########################################

function cdup() {
  echo
  cd ..
  zle reset-prompt
}

zle -N cdup
bindkey '^u' cdup

########################################
# function
########################################

function epoch() {
  if ( test -n "$1" ); then;
    date -r $1 +%Y-%m-%dT%H:%M:%S%z
  else
    date +%s
  fi
}

function inside-git-repository() {
  if ( git rev-parse --is-inside-work-tree > /dev/null 2>&1 ); then
    return 0
  else
    return 1
  fi
}

function git-default-branch() {
  default=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  if ( test -n "${default}" ); then
    echo ${default}
  else
    echo 'master'
  fi
}

function git-checkout-master() {
  git checkout $(git-default-branch)
}

function git-root() {
  if ( inside-git-repository ); then
    cd $(pwd)/$(git rev-parse --show-cdup)
  else
    echo "Not a git repository"
    return 1
  fi
}
zle -N git-root
bindkey '^p' git-root

stty stop undef
function peco-src() {
  local selected_repos=$(ghq list | peco --prompt 'REPOSITORY >' | head -n 1)
  if ( test -n "$selected_repos" ); then
      if ( test -d "${GHQPATH}/${selected_repos}" ); then
          BUFFER="cd ${GHQPATH}/${selected_repos}"
      else
          BUFFER="cd ${GOPATH}/src/${selected_repos}"
      fi
      zle accept-line
      zle clear-screen
  fi
}
zle -N peco-src
bindkey '^s' peco-src

function peco-history() {
  BUFFER=$(history -n 1 | eval tail -r | peco --prompt 'HISTORY >' | head -n 1)
  CURSOR="${#BUFFER}"
  zle clear-screen
}
zle -N peco-history
bindkey '^r' peco-history

function peco-file() {
  if ( test -n "${BUFFER}" ); then
    local selected_files=$(ag -l | peco --prompt 'FILE >' | tr '\n' ' ')
    local cmd=$(echo ${BUFFER} | sed -e "s/ $//g")
    BUFFER="${cmd} ${selected_files}"
    CURSOR="${#BUFFER}"
  else
    exec ag -l | peco --exec "xargs -o ${EDITOR}"
  fi
}
zle -N peco-file
bindkey '^f' peco-file

function peco-branch() {
  local selected_branch=$(git branch | peco --prompt "BRANCH >" | head -n 1 | sed -e "s/^\*//g" | sed -e "s/ //g")
  if ( test -n "${selected_branch}" ); then
    if ( test -n "${BUFFER}" ); then
      local cmd=$(echo ${BUFFER} | sed -e "s/ $//g")
      BUFFER="${cmd} ${selected_branch}"
      CURSOR="${#BUFFER}"
    else
      BUFFER="git checkout ${selected_branch}"
      zle accept-line
    fi
  fi
}
zle -N peco-branch
bindkey '^b' peco-branch

function peco-ssh() {
    local target=$(grep -h "^\s*Host " ${HOME}/.ssh/config $(find ${HOME}/.ssh/conf.d -type f 2>/dev/null) | grep -v "*" | sed s/"[\s ]*Host "// | sort | peco --prompt 'HOST >' | head -n 1)
    ssh ${target}
}
alias ss='peco-ssh'

function pero() {
  if ( test "${EDITOR}" = "code" ); then
    exec ag "${@}" . | peco --exec 'head -n 1 | awk -F : '"'"'{print "-g " $1 ":" $2}'"'"' | xargs -o code'
  else
    exec ag "${@}" . | peco --exec 'head -n 1 | awk -F : '"'"'{print "+" $2 " " $1}'"'"' | xargs -o ${EDITOR}'
  fi
}

function peco-explore() {
  local pwd=$(pwd)
  local selected=$(echo ".\n..\n$(ls -p --color=none)" | peco --prompt "${pwd} >")
  if ( test -n "${selected}" ); then
    if ( test -d "${selected}" ); then
      if ( test "${selected}" != "." ); then
        cd ${selected}
        peco-explore
      fi
    else
      zle accept-line
      local cmd=$(echo ${BUFFER} | sed -e "s/ $//g")
      if ( test -n "${cmd}" ); then
        BUFFER="${cmd} ${selected}"
        CURSOR="${#BUFFER}"
      else
        file --mime "${selected}" | grep "charset=binary" >/dev/null
        local is_binary=$?
        if ( test "${is_binary}" -eq 0 ); then
          BUFFER="${selected}"
          CURSOR="${#BUFFER}"
        else
          BUFFER="${EDITOR} ${selected}"
          zle accept-line
        fi
      fi
    fi
  else
    zle accept-line
  fi
}
zle -N peco-explore
bindkey '^e' peco-explore

function peco-cd() {
  local selected=$(dirs -v | cut -f2 | peco)
  if ( test -n "${selected}" ); then
    BUFFER="cd ${selected}"
    zle accept-line
  fi
}
zle -N peco-cd
bindkey '^d' peco-cd
